// with keyword adds a 'mixin' which is basically 'inheritance-lite'
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import './product.dart';
import '../models/http_exception.dart';

class Products with ChangeNotifier {
  List<Product> _items = [];

// Made this copy of the above private list because when we change data in this list via some other widget , we wouldn't be able to run the notifylisteners() function to let all the other  widgets know that the data has been changed
  List<Product> get items {
    return [..._items];
  }

  final String authToken;

  Products(this.authToken, this._items);

  List<Product> get favoriteItems {
    return _items.where((element) => element.isFavorite == true).toList();
  }

// Defined a logic to get all the data of a particular product just using it's id (provided we already have the id)
  Product findById(String getId) {
    return items.firstWhere((element) => getId == element.id);
  }

  Future<void> fetchProducts() async {
    final url = Uri.parse(
        'https://flutter-shop-app-6565c-default-rtdb.asia-southeast1.firebasedatabase.app/products.json?auth=$authToken');
    try {
      final response = await http.get(url);
      final extractedData = json.decode(response.body) as Map<String, dynamic>;
      final List<Product> loadedProducts = [];
      if (extractedData == null) {
        _items = [];
        return;
      }
      extractedData.forEach((prodId, prodData) {
        loadedProducts.add(Product(
          id: prodId,
          title: prodData['title'],
          description: prodData['description'],
          price: prodData['price'],
          imageUrl: prodData['imageUrl'],
          isFavorite: prodData['isFavorite'],
        ));
      });
      _items = loadedProducts;
      notifyListeners();
    } catch (error) {
      throw (error);
    }
  }

// changed the following function to return a future since we want a loading screen
  Future<void> addProduct(Product product) async {
    try {
      final url = Uri.parse(
          'https://flutter-shop-app-6565c-default-rtdb.asia-southeast1.firebasedatabase.app/products.json');
      final response = await http.post(
        url,
        body: json.encode({
          'title': product.title,
          'description': product.description,
          'price': product.price,
          'imageUrl': product.imageUrl,
          'isFavorite': product.isFavorite,
        }),
      );
      final newProduct = Product(
        title: product.title,
        description: product.description,
        price: product.price,
        imageUrl: product.imageUrl,
        id: json.decode(response.body)['name'],
        // Not gonna use this datetime id , instead we're gonna use the id generated by firebase
        // id: DateTime.now().toString(),
      );
      _items.add(newProduct);
      notifyListeners();
    } catch (error) {
      print(error);
      throw error;
    }
  }

  Future<void> updateProduct(String id, Product newProduct) async {
    final prodIndex = _items.indexWhere((element) => element.id == id);
    if (prodIndex >= 0) {
      final url = Uri.parse(
          'https://flutter-shop-app-6565c-default-rtdb.asia-southeast1.firebasedatabase.app/products/$id.json');
      await http.patch(url,
          body: json.encode({
            'title': newProduct.title,
            'description': newProduct.description,
            'imageUrl': newProduct.imageUrl,
            'price': newProduct.price,
          }));
      _items[prodIndex] = newProduct;
      notifyListeners();
    } else {
      print('Update product failed.......');
    }
  }

  Future<void> deleteProduct(String id) async {
    final url = Uri.parse(
        'https://flutter-shop-app-6565c-default-rtdb.asia-southeast1.firebasedatabase.app/products/$id.json');
    final existingProductIndex =
        _items.indexWhere((element) => id == element.id);

    var existingProduct = _items[existingProductIndex];

    _items.removeAt(existingProductIndex);
    notifyListeners();

    // This approach makes sure that if any error occurs while sending the delte http request, we can store the deleted product in memory and insert it back into our main list in the memory so that it's still there.
    // This approach is also called optimistic updating
    final response = await http.delete(url);

    // Here we're defining our own error since catcherror doesnt get executed in http.delete  for some reason, unlike get and post.
    if (response.statusCode >= 400) {
      _items.insert(existingProductIndex, existingProduct);
      notifyListeners();
      // I would've just used Exception here, but dart team encourages to make your own Exception classes, so did that
      throw HttpException('Could not delete product!');
    }
    // Throw is like, return . the function execution will stop in if()
    existingProduct = null;
  }
}
